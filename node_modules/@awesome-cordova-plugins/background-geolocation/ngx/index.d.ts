import { AwesomeCordovaNativePlugin } from '@awesome-cordova-plugins/core';
import { Observable } from 'rxjs';
import * as ɵngcc0 from '@angular/core';
export declare enum BackgroundGeolocationLocationCode {
    PERMISSION_DENIED = 1,
    LOCATION_UNAVAILABLE = 2,
    TIMEOUT = 3
}
export declare enum BackgroundGeolocationNativeProvider {
    gps = "gps",
    network = "network",
    passive = "passive",
    fused = "fused"
}
export declare enum BackgroundGeolocationLocationProvider {
    DISTANCE_FILTER_PROVIDER = 0,
    ACTIVITY_PROVIDER = 1,
    RAW_PROVIDER = 2
}
export declare enum BackgroundGeolocationEvents {
    http_authorization = "http_authorization",
    abort_requested = "abort_requested",
    background = "background",
    foreground = "foreground",
    authorization = "authorization",
    error = "error",
    stop = "stop",
    start = "start",
    activity = "activity",
    stationary = "stationary",
    location = "location"
}
export declare enum BackgroundGeolocationAuthorizationStatus {
    NOT_AUTHORIZED = 0,
    AUTHORIZED = 1,
    AUTHORIZED_FOREGROUND = 2
}
export declare enum BackgroundGeolocationLogLevel {
    TRACE = "TRACE",
    DEBUG = "DEBUG",
    INFO = "INFO",
    WARN = "WARN",
    ERROR = "ERROR"
}
export interface BackgroundGeolocationLogEntry {
    /** ID of log entry as stored in db. */
    id: number;
    /** Timestamp in milliseconds since beginning of UNIX epoch. */
    timestamp: number;
    /** Log level */
    level: BackgroundGeolocationLogLevel;
    /** Log message */
    message: string;
    /** Recorded stacktrace. (Android only, on iOS part of message) */
    stackTrace: string;
}
export interface ServiceStatus {
    /** TRUE if service is running. */
    isRunning: boolean;
    /** TRUE if location services are enabled */
    locationServicesEnabled: boolean;
    /**
     * Authorization status.
     *
     * Posible values:
     *  NOT_AUTHORIZED, AUTHORIZED, AUTHORIZED_FOREGROUND
     *
     * @example
     * if (authorization == BackgroundGeolocation.NOT_AUTHORIZED) {...}
     */
    authorization: BackgroundGeolocationAuthorizationStatus;
}
export interface BackgroundGeolocation {
    code: BackgroundGeolocationLocationCode;
    message: string;
}
export interface BackgroundGeolocationCurrentPositionConfig {
    timeout: number;
    maximumAge: number;
    enableHighAccuracy: boolean;
}
export interface BackgroundGeolocationResponse {
    /** ID of location as stored in DB (or null) */
    id: number;
    /**
     * Native provider reponsible for location.
     *
     * Possible values:
     * "gps", "network", "passive" or "fused"
     */
    provider: BackgroundGeolocationNativeProvider;
    /** Configured location provider. */
    locationProvider: BackgroundGeolocationLocationProvider;
    /** UTC time of this fix, in milliseconds since January 1, 1970. */
    time: number;
    /** Latitude, in degrees. */
    latitude: number;
    /** Longitude, in degrees. */
    longitude: number;
    /** Estimated accuracy of this location, in meters. */
    accuracy: number;
    /**
     * Speed if it is available, in meters/second over ground.
     *
     * Note: Not all providers are capable of providing speed.
     * Typically network providers are not able to do so.
     */
    speed: number;
    /** Altitude if available, in meters above the WGS 84 reference ellipsoid. */
    altitude: number;
    /** Bearing, in degrees. */
    bearing: number;
    /**
     * True if location was recorded by mock provider. (ANDROID ONLY)
     *
     * Note: this property is not enabled by default!
     * You can enable it "postTemplate" configure option.
     */
    isFromMockProvider?: boolean;
    /**
     * True if device has mock locations enabled. (ANDROID ONLY)
     *
     * Note: this property is not enabled by default!
     * You can enable it "postTemplate" configure option.
     */
    mockLocationsEnabled?: boolean;
}
export interface BackgroundGeolocationConfig {
    /**
     * Set location provider
     *
     * Platform: all
     * Available providers:
     *  DISTANCE_FILTER_PROVIDER,
     *  ACTIVITY_PROVIDER
     *  RAW_PROVIDER
     *
     * @default DISTANCE_FILTER_PROVIDER
     * @example
     * { locationProvider: LocationProvider.RAW_PROVIDER }
     */
    locationProvider?: number;
    /**
     * Desired accuracy in meters.
     *
     * Platform: all
     * Provider: all
     * Possible values:
     *  HIGH_ACCURACY,
     *  MEDIUM_ACCURACY,
     *  LOW_ACCURACY,
     *  PASSIVE_ACCURACY
     * Note: Accuracy has direct effect on power drain. Lower accuracy = lower power drain.
     *
     * @default MEDIUM_ACCURACY
     * @example
     * { desiredAccuracy: BackgroundGeolocationAccuracy.LOW }
     */
    desiredAccuracy?: number;
    /**
     * Stationary radius in meters.
     *
     * When stopped, the minimum distance the device must move beyond the stationary location for aggressive background-tracking to engage.
     * Platform: all
     * Provider: DISTANCE_FILTER
     *
     * @default 50
     */
    stationaryRadius?: number;
    /**
     * When enabled, the plugin will emit sounds for life-cycle events of background-geolocation! See debugging sounds table.
     *
     * Platform: all
     * Provider: all
     *
     * @default false
     */
    debug?: boolean;
    /**
     * The minimum distance (measured in meters) a device must move horizontally before an update event is generated.
     *
     * Platform: all
     * Provider: DISTANCE_FILTER, RAW
     *
     * @default 500
     * @see {@link https://apple.co/2oHo2CV|Apple docs}
     */
    distanceFilter?: number;
    /**
     * Enable this in order to force a stop() when the application terminated.
     * E.g. on iOS, double-tap home button, swipe away the app.
     *
     * Platform: all
     * Provider: all
     *
     * @default true
     */
    stopOnTerminate?: boolean;
    /**
     * Start background service on device boot.
     *
     * Platform: Android
     * Provider: all
     *
     * @default false
     */
    startOnBoot?: boolean;
    /**
     * The minimum time interval between location updates in milliseconds.
     *
     * Platform: Android
     * Provider: all
     *
     * @default 60000
     * @see {@link https://bit.ly/1x00RUu|Android docs}
     */
    interval?: number;
    /**
     * Fastest rate in milliseconds at which your app can handle location updates.
     *
     * Platform: Android
     * Provider: ACTIVITY
     *
     * @default 120000
     * @see {@link https://bit.ly/1x00RUu|Android docs}
     */
    fastestInterval?: number;
    /**
     * Rate in milliseconds at which activity recognition occurs.
     * Larger values will result in fewer activity detections while improving battery life.
     *
     * Platform: Android
     * Provider: ACTIVITY
     *
     * @default 10000
     */
    activitiesInterval?: number;
    /**
     * @deprecated Stop location updates, when the STILL activity is detected.
     */
    stopOnStillActivity?: boolean;
    /**
     * Enable/disable local notifications when tracking and syncing locations.
     *
     * Platform: Android
     * Provider: all
     *
     * @default true
     */
    notificationsEnabled?: boolean;
    /**
     * Allow location sync service to run in foreground state.
     * Foreground state also requires a notification to be presented to the user.
     *
     * Platform: Android
     * Provider: all
     *
     * @default false
     */
    startForeground?: boolean;
    /**
     * Custom notification title in the drawer.
     *
     * Platform: Android
     * Provider: all
     *
     * @default "Background tracking"
     */
    notificationTitle?: string;
    /**
     * Custom notification text in the drawer.
     *
     * Platform: Android
     * Provider: all
     *
     * @default "ENABLED"
     */
    notificationText?: string;
    /**
     * The accent color (hex triplet) to use for notification.
     * Eg. <code>#4CAF50</code>.
     *
     * Platform: Android
     * Provider: all
     */
    notificationIconColor?: string;
    /**
     * The filename of a custom notification icon.
     *
     * Platform: Android
     * Provider: all
     */
    notificationIconLarge?: string;
    /**
     * The filename of a custom notification icon.
     *
     * Platform: Android
     * Provider: all
     */
    notificationIconSmall?: string;
    /**
     * Activity type.
     * Presumably, this affects iOS GPS algorithm.
     *
     * Possible values:
     * "AutomotiveNavigation", "OtherNavigation", "Fitness", "Other"
     *
     * Platform: iOS
     * Provider: all
     *
     * @default "OtherNavigation"
     * @see {@link https://apple.co/2oHofpH|Apple docs}
     */
    activityType?: string;
    /**
     * Pauses location updates when app is paused.
     *
     * Platform: iOS
     * Provider: all
     *
     * @default false
     * @see {@link https://apple.co/2CbjEW2|Apple docs}
     */
    pauseLocationUpdates?: boolean;
    /**
     * Switch to less accurate significant changes and region monitory when in background.
     *
     * Platform: iOS
     * Provider: all
     *
     * @default false
     */
    saveBatteryOnBackground?: boolean;
    /**
     * Server url where to send HTTP POST with recorded locations
     *
     * Platform: all
     * Provider: all
     */
    url?: string;
    /**
     * Server url where to send fail to post locations
     *
     * Platform: all
     * Provider: all
     */
    syncUrl?: string;
    /**
     * Specifies how many previously failed locations will be sent to server at once.
     *
     * Platform: all
     * Provider: all
     *
     * @default 100
     */
    syncThreshold?: number;
    /**
     * Optional HTTP headers sent along in HTTP request.
     *
     * Platform: all
     * Provider: all
     */
    httpHeaders?: any;
    /**
     * Limit maximum number of locations stored into db.
     *
     * Platform: all
     * Provider: all
     *
     * @default 10000
     */
    maxLocations?: number;
    /**
     * Customization post template.
     *
     * Platform: all
     * Provider: all
     */
    postTemplate?: any;
}
/**
 * Set location service provider @see https://github.com/mauron85/cordova-plugin-background-geolocation/wiki/Android-providers
 *
 * Possible values:
 *  ANDROID_DISTANCE_FILTER_PROVIDER: 0,
 *  ANDROID_ACTIVITY_PROVIDER: 1
 *
 * @enum {number}
 */
export declare enum BackgroundGeolocationProvider {
    ANDROID_DISTANCE_FILTER_PROVIDER = 0,
    ANDROID_ACTIVITY_PROVIDER = 1
}
/**
 * Desired accuracy in meters. Possible values [0, 10, 100, 1000].
 * The lower the number, the more power devoted to GeoLocation resulting in higher accuracy readings.
 * 1000 results in lowest power drain and least accurate readings.
 *
 * Possible values:
 *  HIGH: 0
 *  MEDIUM: 10
 *  LOW: 100
 *  PASSIVE: 1000
 *
 * enum {number}
 */
export declare enum BackgroundGeolocationAccuracy {
    HIGH = 0,
    MEDIUM = 10,
    LOW = 100,
    PASSIVE = 1000
}
/**
 * Used in the switchMode function
 *
 * Possible values:
 *  BACKGROUND: 0
 *  FOREGROUND: 1
 *
 * @enum {number}
 */
export declare enum BackgroundGeolocationMode {
    BACKGROUND = 0,
    FOREGROUND = 1
}
export declare enum BackgroundGeolocationIOSActivity {
    AutomotiveNavigation = "AutomotiveNavigation",
    OtherNavigation = "OtherNavigation",
    Fitness = "Fitness",
    Other = "Other"
}
/**
 * @name Background Geolocation
 * @description
 * This plugin provides foreground and background geolocation with battery-saving "circular region monitoring" and "stop detection". For
 * more detail, please see https://github.com/mauron85/cordova-plugin-background-geolocation
 * @usage
 *
 * BackgroundGeolocation must be called within app.ts and or before Geolocation. Otherwise the platform will not ask you for background tracking permission.
 *
 * ```typescript
 * import { BackgroundGeolocation, BackgroundGeolocationConfig, BackgroundGeolocationEvents, BackgroundGeolocationResponse } from '@awesome-cordova-plugins/background-geolocation/ngx';
 *
 * constructor(private backgroundGeolocation: BackgroundGeolocation) { }
 *
 * ...
 *
 * const config: BackgroundGeolocationConfig = {
 *             desiredAccuracy: 10,
 *             stationaryRadius: 20,
 *             distanceFilter: 30,
 *             debug: true, //  enable this hear sounds for background-geolocation life-cycle.
 *             stopOnTerminate: false, // enable this to clear background location settings when the app terminates
 *     };
 *
 * this.backgroundGeolocation.configure(config)
 *   .then(() => {
 *
 *     this.backgroundGeolocation.on(BackgroundGeolocationEvents.location).subscribe((location: BackgroundGeolocationResponse) => {
 *       console.log(location);
 *
 *       // IMPORTANT:  You must execute the finish method here to inform the native plugin that you're finished,
 *       // and the background-task may be completed.  You must do this regardless if your operations are successful or not.
 *       // IF YOU DON'T, ios will CRASH YOUR APP for spending too much time in the background.
 *       this.backgroundGeolocation.finish(); // FOR IOS ONLY
 *     });
 *
 *   });
 *
 * // start recording location
 * this.backgroundGeolocation.start();
 *
 * // If you wish to turn OFF background-tracking, call the #stop method.
 * this.backgroundGeolocation.stop();
 *
 * ```
 * @interfaces
 * BackgroundGeolocationResponse
 * BackgroundGeolocationConfig
 */
export declare class BackgroundGeolocation extends AwesomeCordovaNativePlugin {
    /**
     * Configure the plugin.
     *
     * @param options {BackgroundGeolocationConfig} options An object of type Config
     * @returns {Promise<any>}
     */
    configure(options: BackgroundGeolocationConfig): Promise<any>;
    /**
     * Turn ON the background-geolocation system.
     * The user will be tracked whenever they suspend the app.
     *
     * @returns {Promise<any>}
     */
    start(): Promise<any>;
    /**
     * Turn OFF background-tracking
     *
     * @returns {Promise<any>}
     */
    stop(): Promise<any>;
    /**
     * Inform the native plugin that you're finished, the background-task may be completed
     *
     * @returns {Promise<any>}
     */
    finish(): Promise<any>;
    /**
     * Force the plugin to enter "moving" or "stationary" state
     *
     * @param isMoving {boolean}
     * @returns {Promise<any>}
     */
    changePace(isMoving: boolean): Promise<any>;
    /**
     * Setup configuration
     *
     * @param options {BackgroundGeolocationConfig}
     * @returns {Promise<any>}
     */
    setConfig(options: BackgroundGeolocationConfig): Promise<any>;
    /**
     * Returns current stationaryLocation if available. null if not
     *
     * @returns {Promise<Location>}
     */
    getStationaryLocation(): Promise<BackgroundGeolocationResponse>;
    /**
     * Add a stationary-region listener. Whenever the devices enters "stationary-mode",
     * your #success callback will be executed with #location param containing #radius of region
     *
     * @returns {Promise<any>}
     */
    onStationary(): Promise<any>;
    /**
     * Check if location is enabled on the device
     *
     * @returns {Promise<number>} Returns a promise with int argument that takes values 0, 1 (true).
     */
    isLocationEnabled(): Promise<number>;
    /**
     * Display app settings to change permissions
     */
    showAppSettings(): void;
    /**
     * Display device location settings
     */
    showLocationSettings(): void;
    /**
     * Method can be used to detect user changes in location services settings.
     * If user enable or disable location services then success callback will be executed.
     * In case or  (SettingNotFoundException) fail callback will be executed.
     *
     * @returns {Observable<number>}
     */
    watchLocationMode(): Observable<number>;
    /**
     * Stop watching for location mode changes.
     *
     * @returns {Promise<any>}
     */
    stopWatchingLocationMode(): Promise<any>;
    /**
     * Method will return all stored locations.
     * Locations are stored when:
     *  - config.stopOnTerminate is false and main activity was killed
     *    by the system
     *  or
     *  - option.debug is true
     *
     * @returns {Promise<any>}
     */
    getLocations(): Promise<any>;
    /**
     * Method will return locations, which has not been yet posted to server. NOTE: Locations does contain locationId.
     *
     * @returns {Promise<any>}
     */
    getValidLocations(): Promise<any>;
    /**
     * Delete stored location by given locationId.
     *
     * @param locationId {number}
     * @returns {Promise<any>}
     */
    deleteLocation(locationId: number): Promise<any>;
    /**
     * Delete all stored locations.
     *
     * @returns {Promise<any>}
     */
    deleteAllLocations(): Promise<any>;
    /**
     * Normally plugin will handle switching between BACKGROUND and FOREGROUND mode itself.
     * Calling switchMode you can override plugin behavior and force plugin to switch into other mode.
     *
     * In FOREGROUND mode plugin uses iOS local manager to receive locations and behavior is affected by option.desiredAccuracy and option.distanceFilter.
     * In BACKGROUND mode plugin uses significant changes and region monitoring to receive locations and uses option.stationaryRadius only.
     *
     * BackgroundGeolocation.Mode.FOREGROUND
     * BackgroundGeolocation.Mode.BACKGROUND
     *
     * @param modeId {number}
     * @returns {Promise<any>}
     */
    switchMode(modeId: number): Promise<any>;
    /**
     * Return all logged events. Useful for plugin debugging. Parameter limit limits number of returned entries.
     *
     * @see https://github.com/mauron85/cordova-plugin-background-geolocation/tree/v2.2.1#debugging for more information.
     * @param fromId
     * @param minLevel
     * @param limit {number} Limits the number of entries
     * @returns {Promise<any>}
     */
    getLogEntries(limit: number, fromId: number, minLevel: BackgroundGeolocationLogLevel): Promise<BackgroundGeolocationLogEntry[]>;
    /**
     * Return all logged events. Useful for plugin debugging. Parameter limit limits number of returned entries.
     *
     * @see https://github.com/mauron85/cordova-plugin-background-geolocation/tree/v2.2.1#debugging for more information.
     * @returns {Promise<any>}
     */
    getConfig(): Promise<any>;
    /**
     * One time location check to get current location of the device.
     * {timeout: Maximum time in milliseconds device will wait for location,
     * maximumAge: Maximum age in milliseconds of a possible cached location that is acceptable to return;
     * enableHighAccuracy: if true and if the device is able to provide a more accurate position, it will do so}
     *
     * @param {BackgroundGeolocationCurrentPositionConfig} options
     * @returns {Promise<any>}
     */
    getCurrentLocation(options?: BackgroundGeolocationCurrentPositionConfig): Promise<BackgroundGeolocationResponse>;
    /**
     * Check status of the service
     */
    checkStatus(): Promise<ServiceStatus>;
    /**
     * Start background task (iOS only)
     *
     * To perform any long running operation on iOS
     * you need to create background task
     * IMPORTANT: task has to be ended by endTask
     *
     * @returns {Promise<number>} taskKey
     */
    startTask(): Promise<number>;
    /**
     *  End background task indentified by taskKey (iOS only)
     *
     * @param taskKey
     */
    endTask(taskKey: number): Promise<any>;
    /**
     * A special task that gets executed when the app is terminated, but
     * the plugin was configured to continue running in the background
     * (option <code>stopOnTerminate: false</code>).
     *
     * In this scenario the Activity was killed by the system and all registered
     * event listeners will not be triggered until the app is relaunched.
     *
     * @example
     *  BackgroundGeolocation.headlessTask(function(event) {
     *
     *      if (event.name === 'location' || event.name === 'stationary') {
     *          var xhr = new XMLHttpRequest();
     *          xhr.open('POST', 'http://192.168.81.14:3000/headless');
     *          xhr.setRequestHeader('Content-Type', 'application/json');
     *          xhr.send(JSON.stringify(event.params));
     *      }
     *
     *      return 'Processing event: ' + event.name; // will be logged
     *  });
     * @param func
     */
    headlessTask(func: any): Promise<any>;
    /**
     * Force sync of pending locations.
     * Option <code>syncThreshold</code> will be ignored and all pending locations will be immediately posted to <code>syncUrl</code> in single batch.
     *
     * Platform: Android, iOS
     */
    forceSync(): Promise<any>;
    /**
     * Register event listener.
     *
     * Triggered when server responded with "<code>285 Updates Not Required</code>" to post/sync request.
     *
     * @param event
     * @param callbackFn
     */
    on(event: BackgroundGeolocationEvents): Observable<BackgroundGeolocationResponse>;
    /**
     * Unregister all event listeners for given event.
     *
     * If parameter <code>event</code> is not provided then all event listeners will be removed.
     *
     * @param event
     */
    removeAllListeners(event?: BackgroundGeolocationEvents): Promise<any>;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<BackgroundGeolocation, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<BackgroundGeolocation>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZC50cyIsInNvdXJjZXMiOlsiaW5kZXguZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEF3ZXNvbWVDb3Jkb3ZhTmF0aXZlUGx1Z2luIH0gZnJvbSAnQGF3ZXNvbWUtY29yZG92YS1wbHVnaW5zL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuZXhwb3J0IGRlY2xhcmUgZW51bSBCYWNrZ3JvdW5kR2VvbG9jYXRpb25Mb2NhdGlvbkNvZGUge1xuICAgIFBFUk1JU1NJT05fREVOSUVEID0gMSxcbiAgICBMT0NBVElPTl9VTkFWQUlMQUJMRSA9IDIsXG4gICAgVElNRU9VVCA9IDNcbn1cbmV4cG9ydCBkZWNsYXJlIGVudW0gQmFja2dyb3VuZEdlb2xvY2F0aW9uTmF0aXZlUHJvdmlkZXIge1xuICAgIGdwcyA9IFwiZ3BzXCIsXG4gICAgbmV0d29yayA9IFwibmV0d29ya1wiLFxuICAgIHBhc3NpdmUgPSBcInBhc3NpdmVcIixcbiAgICBmdXNlZCA9IFwiZnVzZWRcIlxufVxuZXhwb3J0IGRlY2xhcmUgZW51bSBCYWNrZ3JvdW5kR2VvbG9jYXRpb25Mb2NhdGlvblByb3ZpZGVyIHtcbiAgICBESVNUQU5DRV9GSUxURVJfUFJPVklERVIgPSAwLFxuICAgIEFDVElWSVRZX1BST1ZJREVSID0gMSxcbiAgICBSQVdfUFJPVklERVIgPSAyXG59XG5leHBvcnQgZGVjbGFyZSBlbnVtIEJhY2tncm91bmRHZW9sb2NhdGlvbkV2ZW50cyB7XG4gICAgaHR0cF9hdXRob3JpemF0aW9uID0gXCJodHRwX2F1dGhvcml6YXRpb25cIixcbiAgICBhYm9ydF9yZXF1ZXN0ZWQgPSBcImFib3J0X3JlcXVlc3RlZFwiLFxuICAgIGJhY2tncm91bmQgPSBcImJhY2tncm91bmRcIixcbiAgICBmb3JlZ3JvdW5kID0gXCJmb3JlZ3JvdW5kXCIsXG4gICAgYXV0aG9yaXphdGlvbiA9IFwiYXV0aG9yaXphdGlvblwiLFxuICAgIGVycm9yID0gXCJlcnJvclwiLFxuICAgIHN0b3AgPSBcInN0b3BcIixcbiAgICBzdGFydCA9IFwic3RhcnRcIixcbiAgICBhY3Rpdml0eSA9IFwiYWN0aXZpdHlcIixcbiAgICBzdGF0aW9uYXJ5ID0gXCJzdGF0aW9uYXJ5XCIsXG4gICAgbG9jYXRpb24gPSBcImxvY2F0aW9uXCJcbn1cbmV4cG9ydCBkZWNsYXJlIGVudW0gQmFja2dyb3VuZEdlb2xvY2F0aW9uQXV0aG9yaXphdGlvblN0YXR1cyB7XG4gICAgTk9UX0FVVEhPUklaRUQgPSAwLFxuICAgIEFVVEhPUklaRUQgPSAxLFxuICAgIEFVVEhPUklaRURfRk9SRUdST1VORCA9IDJcbn1cbmV4cG9ydCBkZWNsYXJlIGVudW0gQmFja2dyb3VuZEdlb2xvY2F0aW9uTG9nTGV2ZWwge1xuICAgIFRSQUNFID0gXCJUUkFDRVwiLFxuICAgIERFQlVHID0gXCJERUJVR1wiLFxuICAgIElORk8gPSBcIklORk9cIixcbiAgICBXQVJOID0gXCJXQVJOXCIsXG4gICAgRVJST1IgPSBcIkVSUk9SXCJcbn1cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2dyb3VuZEdlb2xvY2F0aW9uTG9nRW50cnkge1xuICAgIC8qKiBJRCBvZiBsb2cgZW50cnkgYXMgc3RvcmVkIGluIGRiLiAqL1xuICAgIGlkOiBudW1iZXI7XG4gICAgLyoqIFRpbWVzdGFtcCBpbiBtaWxsaXNlY29uZHMgc2luY2UgYmVnaW5uaW5nIG9mIFVOSVggZXBvY2guICovXG4gICAgdGltZXN0YW1wOiBudW1iZXI7XG4gICAgLyoqIExvZyBsZXZlbCAqL1xuICAgIGxldmVsOiBCYWNrZ3JvdW5kR2VvbG9jYXRpb25Mb2dMZXZlbDtcbiAgICAvKiogTG9nIG1lc3NhZ2UgKi9cbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgLyoqIFJlY29yZGVkIHN0YWNrdHJhY2UuIChBbmRyb2lkIG9ubHksIG9uIGlPUyBwYXJ0IG9mIG1lc3NhZ2UpICovXG4gICAgc3RhY2tUcmFjZTogc3RyaW5nO1xufVxuZXhwb3J0IGludGVyZmFjZSBTZXJ2aWNlU3RhdHVzIHtcbiAgICAvKiogVFJVRSBpZiBzZXJ2aWNlIGlzIHJ1bm5pbmcuICovXG4gICAgaXNSdW5uaW5nOiBib29sZWFuO1xuICAgIC8qKiBUUlVFIGlmIGxvY2F0aW9uIHNlcnZpY2VzIGFyZSBlbmFibGVkICovXG4gICAgbG9jYXRpb25TZXJ2aWNlc0VuYWJsZWQ6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQXV0aG9yaXphdGlvbiBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBQb3NpYmxlIHZhbHVlczpcbiAgICAgKiAgTk9UX0FVVEhPUklaRUQsIEFVVEhPUklaRUQsIEFVVEhPUklaRURfRk9SRUdST1VORFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBpZiAoYXV0aG9yaXphdGlvbiA9PSBCYWNrZ3JvdW5kR2VvbG9jYXRpb24uTk9UX0FVVEhPUklaRUQpIHsuLi59XG4gICAgICovXG4gICAgYXV0aG9yaXphdGlvbjogQmFja2dyb3VuZEdlb2xvY2F0aW9uQXV0aG9yaXphdGlvblN0YXR1cztcbn1cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2dyb3VuZEdlb2xvY2F0aW9uIHtcbiAgICBjb2RlOiBCYWNrZ3JvdW5kR2VvbG9jYXRpb25Mb2NhdGlvbkNvZGU7XG4gICAgbWVzc2FnZTogc3RyaW5nO1xufVxuZXhwb3J0IGludGVyZmFjZSBCYWNrZ3JvdW5kR2VvbG9jYXRpb25DdXJyZW50UG9zaXRpb25Db25maWcge1xuICAgIHRpbWVvdXQ6IG51bWJlcjtcbiAgICBtYXhpbXVtQWdlOiBudW1iZXI7XG4gICAgZW5hYmxlSGlnaEFjY3VyYWN5OiBib29sZWFuO1xufVxuZXhwb3J0IGludGVyZmFjZSBCYWNrZ3JvdW5kR2VvbG9jYXRpb25SZXNwb25zZSB7XG4gICAgLyoqIElEIG9mIGxvY2F0aW9uIGFzIHN0b3JlZCBpbiBEQiAob3IgbnVsbCkgKi9cbiAgICBpZDogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIE5hdGl2ZSBwcm92aWRlciByZXBvbnNpYmxlIGZvciBsb2NhdGlvbi5cbiAgICAgKlxuICAgICAqIFBvc3NpYmxlIHZhbHVlczpcbiAgICAgKiBcImdwc1wiLCBcIm5ldHdvcmtcIiwgXCJwYXNzaXZlXCIgb3IgXCJmdXNlZFwiXG4gICAgICovXG4gICAgcHJvdmlkZXI6IEJhY2tncm91bmRHZW9sb2NhdGlvbk5hdGl2ZVByb3ZpZGVyO1xuICAgIC8qKiBDb25maWd1cmVkIGxvY2F0aW9uIHByb3ZpZGVyLiAqL1xuICAgIGxvY2F0aW9uUHJvdmlkZXI6IEJhY2tncm91bmRHZW9sb2NhdGlvbkxvY2F0aW9uUHJvdmlkZXI7XG4gICAgLyoqIFVUQyB0aW1lIG9mIHRoaXMgZml4LCBpbiBtaWxsaXNlY29uZHMgc2luY2UgSmFudWFyeSAxLCAxOTcwLiAqL1xuICAgIHRpbWU6IG51bWJlcjtcbiAgICAvKiogTGF0aXR1ZGUsIGluIGRlZ3JlZXMuICovXG4gICAgbGF0aXR1ZGU6IG51bWJlcjtcbiAgICAvKiogTG9uZ2l0dWRlLCBpbiBkZWdyZWVzLiAqL1xuICAgIGxvbmdpdHVkZTogbnVtYmVyO1xuICAgIC8qKiBFc3RpbWF0ZWQgYWNjdXJhY3kgb2YgdGhpcyBsb2NhdGlvbiwgaW4gbWV0ZXJzLiAqL1xuICAgIGFjY3VyYWN5OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU3BlZWQgaWYgaXQgaXMgYXZhaWxhYmxlLCBpbiBtZXRlcnMvc2Vjb25kIG92ZXIgZ3JvdW5kLlxuICAgICAqXG4gICAgICogTm90ZTogTm90IGFsbCBwcm92aWRlcnMgYXJlIGNhcGFibGUgb2YgcHJvdmlkaW5nIHNwZWVkLlxuICAgICAqIFR5cGljYWxseSBuZXR3b3JrIHByb3ZpZGVycyBhcmUgbm90IGFibGUgdG8gZG8gc28uXG4gICAgICovXG4gICAgc3BlZWQ6IG51bWJlcjtcbiAgICAvKiogQWx0aXR1ZGUgaWYgYXZhaWxhYmxlLCBpbiBtZXRlcnMgYWJvdmUgdGhlIFdHUyA4NCByZWZlcmVuY2UgZWxsaXBzb2lkLiAqL1xuICAgIGFsdGl0dWRlOiBudW1iZXI7XG4gICAgLyoqIEJlYXJpbmcsIGluIGRlZ3JlZXMuICovXG4gICAgYmVhcmluZzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgbG9jYXRpb24gd2FzIHJlY29yZGVkIGJ5IG1vY2sgcHJvdmlkZXIuIChBTkRST0lEIE9OTFkpXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbmFibGVkIGJ5IGRlZmF1bHQhXG4gICAgICogWW91IGNhbiBlbmFibGUgaXQgXCJwb3N0VGVtcGxhdGVcIiBjb25maWd1cmUgb3B0aW9uLlxuICAgICAqL1xuICAgIGlzRnJvbU1vY2tQcm92aWRlcj86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiBkZXZpY2UgaGFzIG1vY2sgbG9jYXRpb25zIGVuYWJsZWQuIChBTkRST0lEIE9OTFkpXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbmFibGVkIGJ5IGRlZmF1bHQhXG4gICAgICogWW91IGNhbiBlbmFibGUgaXQgXCJwb3N0VGVtcGxhdGVcIiBjb25maWd1cmUgb3B0aW9uLlxuICAgICAqL1xuICAgIG1vY2tMb2NhdGlvbnNFbmFibGVkPzogYm9vbGVhbjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgQmFja2dyb3VuZEdlb2xvY2F0aW9uQ29uZmlnIHtcbiAgICAvKipcbiAgICAgKiBTZXQgbG9jYXRpb24gcHJvdmlkZXJcbiAgICAgKlxuICAgICAqIFBsYXRmb3JtOiBhbGxcbiAgICAgKiBBdmFpbGFibGUgcHJvdmlkZXJzOlxuICAgICAqICBESVNUQU5DRV9GSUxURVJfUFJPVklERVIsXG4gICAgICogIEFDVElWSVRZX1BST1ZJREVSXG4gICAgICogIFJBV19QUk9WSURFUlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgRElTVEFOQ0VfRklMVEVSX1BST1ZJREVSXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB7IGxvY2F0aW9uUHJvdmlkZXI6IExvY2F0aW9uUHJvdmlkZXIuUkFXX1BST1ZJREVSIH1cbiAgICAgKi9cbiAgICBsb2NhdGlvblByb3ZpZGVyPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIERlc2lyZWQgYWNjdXJhY3kgaW4gbWV0ZXJzLlxuICAgICAqXG4gICAgICogUGxhdGZvcm06IGFsbFxuICAgICAqIFByb3ZpZGVyOiBhbGxcbiAgICAgKiBQb3NzaWJsZSB2YWx1ZXM6XG4gICAgICogIEhJR0hfQUNDVVJBQ1ksXG4gICAgICogIE1FRElVTV9BQ0NVUkFDWSxcbiAgICAgKiAgTE9XX0FDQ1VSQUNZLFxuICAgICAqICBQQVNTSVZFX0FDQ1VSQUNZXG4gICAgICogTm90ZTogQWNjdXJhY3kgaGFzIGRpcmVjdCBlZmZlY3Qgb24gcG93ZXIgZHJhaW4uIExvd2VyIGFjY3VyYWN5ID0gbG93ZXIgcG93ZXIgZHJhaW4uXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCBNRURJVU1fQUNDVVJBQ1lcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHsgZGVzaXJlZEFjY3VyYWN5OiBCYWNrZ3JvdW5kR2VvbG9jYXRpb25BY2N1cmFjeS5MT1cgfVxuICAgICAqL1xuICAgIGRlc2lyZWRBY2N1cmFjeT86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBTdGF0aW9uYXJ5IHJhZGl1cyBpbiBtZXRlcnMuXG4gICAgICpcbiAgICAgKiBXaGVuIHN0b3BwZWQsIHRoZSBtaW5pbXVtIGRpc3RhbmNlIHRoZSBkZXZpY2UgbXVzdCBtb3ZlIGJleW9uZCB0aGUgc3RhdGlvbmFyeSBsb2NhdGlvbiBmb3IgYWdncmVzc2l2ZSBiYWNrZ3JvdW5kLXRyYWNraW5nIHRvIGVuZ2FnZS5cbiAgICAgKiBQbGF0Zm9ybTogYWxsXG4gICAgICogUHJvdmlkZXI6IERJU1RBTkNFX0ZJTFRFUlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgNTBcbiAgICAgKi9cbiAgICBzdGF0aW9uYXJ5UmFkaXVzPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFdoZW4gZW5hYmxlZCwgdGhlIHBsdWdpbiB3aWxsIGVtaXQgc291bmRzIGZvciBsaWZlLWN5Y2xlIGV2ZW50cyBvZiBiYWNrZ3JvdW5kLWdlb2xvY2F0aW9uISBTZWUgZGVidWdnaW5nIHNvdW5kcyB0YWJsZS5cbiAgICAgKlxuICAgICAqIFBsYXRmb3JtOiBhbGxcbiAgICAgKiBQcm92aWRlcjogYWxsXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGRlYnVnPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgbWluaW11bSBkaXN0YW5jZSAobWVhc3VyZWQgaW4gbWV0ZXJzKSBhIGRldmljZSBtdXN0IG1vdmUgaG9yaXpvbnRhbGx5IGJlZm9yZSBhbiB1cGRhdGUgZXZlbnQgaXMgZ2VuZXJhdGVkLlxuICAgICAqXG4gICAgICogUGxhdGZvcm06IGFsbFxuICAgICAqIFByb3ZpZGVyOiBESVNUQU5DRV9GSUxURVIsIFJBV1xuICAgICAqXG4gICAgICogQGRlZmF1bHQgNTAwXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcHBsZS5jby8yb0hvMkNWfEFwcGxlIGRvY3N9XG4gICAgICovXG4gICAgZGlzdGFuY2VGaWx0ZXI/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRoaXMgaW4gb3JkZXIgdG8gZm9yY2UgYSBzdG9wKCkgd2hlbiB0aGUgYXBwbGljYXRpb24gdGVybWluYXRlZC5cbiAgICAgKiBFLmcuIG9uIGlPUywgZG91YmxlLXRhcCBob21lIGJ1dHRvbiwgc3dpcGUgYXdheSB0aGUgYXBwLlxuICAgICAqXG4gICAgICogUGxhdGZvcm06IGFsbFxuICAgICAqIFByb3ZpZGVyOiBhbGxcbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBzdG9wT25UZXJtaW5hdGU/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IGJhY2tncm91bmQgc2VydmljZSBvbiBkZXZpY2UgYm9vdC5cbiAgICAgKlxuICAgICAqIFBsYXRmb3JtOiBBbmRyb2lkXG4gICAgICogUHJvdmlkZXI6IGFsbFxuICAgICAqXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBzdGFydE9uQm9vdD86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIG1pbmltdW0gdGltZSBpbnRlcnZhbCBiZXR3ZWVuIGxvY2F0aW9uIHVwZGF0ZXMgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqXG4gICAgICogUGxhdGZvcm06IEFuZHJvaWRcbiAgICAgKiBQcm92aWRlcjogYWxsXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCA2MDAwMFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYml0Lmx5LzF4MDBSVXV8QW5kcm9pZCBkb2NzfVxuICAgICAqL1xuICAgIGludGVydmFsPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEZhc3Rlc3QgcmF0ZSBpbiBtaWxsaXNlY29uZHMgYXQgd2hpY2ggeW91ciBhcHAgY2FuIGhhbmRsZSBsb2NhdGlvbiB1cGRhdGVzLlxuICAgICAqXG4gICAgICogUGxhdGZvcm06IEFuZHJvaWRcbiAgICAgKiBQcm92aWRlcjogQUNUSVZJVFlcbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IDEyMDAwMFxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vYml0Lmx5LzF4MDBSVXV8QW5kcm9pZCBkb2NzfVxuICAgICAqL1xuICAgIGZhc3Rlc3RJbnRlcnZhbD86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBSYXRlIGluIG1pbGxpc2Vjb25kcyBhdCB3aGljaCBhY3Rpdml0eSByZWNvZ25pdGlvbiBvY2N1cnMuXG4gICAgICogTGFyZ2VyIHZhbHVlcyB3aWxsIHJlc3VsdCBpbiBmZXdlciBhY3Rpdml0eSBkZXRlY3Rpb25zIHdoaWxlIGltcHJvdmluZyBiYXR0ZXJ5IGxpZmUuXG4gICAgICpcbiAgICAgKiBQbGF0Zm9ybTogQW5kcm9pZFxuICAgICAqIFByb3ZpZGVyOiBBQ1RJVklUWVxuICAgICAqXG4gICAgICogQGRlZmF1bHQgMTAwMDBcbiAgICAgKi9cbiAgICBhY3Rpdml0aWVzSW50ZXJ2YWw/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgU3RvcCBsb2NhdGlvbiB1cGRhdGVzLCB3aGVuIHRoZSBTVElMTCBhY3Rpdml0eSBpcyBkZXRlY3RlZC5cbiAgICAgKi9cbiAgICBzdG9wT25TdGlsbEFjdGl2aXR5PzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBFbmFibGUvZGlzYWJsZSBsb2NhbCBub3RpZmljYXRpb25zIHdoZW4gdHJhY2tpbmcgYW5kIHN5bmNpbmcgbG9jYXRpb25zLlxuICAgICAqXG4gICAgICogUGxhdGZvcm06IEFuZHJvaWRcbiAgICAgKiBQcm92aWRlcjogYWxsXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgbm90aWZpY2F0aW9uc0VuYWJsZWQ/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEFsbG93IGxvY2F0aW9uIHN5bmMgc2VydmljZSB0byBydW4gaW4gZm9yZWdyb3VuZCBzdGF0ZS5cbiAgICAgKiBGb3JlZ3JvdW5kIHN0YXRlIGFsc28gcmVxdWlyZXMgYSBub3RpZmljYXRpb24gdG8gYmUgcHJlc2VudGVkIHRvIHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogUGxhdGZvcm06IEFuZHJvaWRcbiAgICAgKiBQcm92aWRlcjogYWxsXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIHN0YXJ0Rm9yZWdyb3VuZD86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQ3VzdG9tIG5vdGlmaWNhdGlvbiB0aXRsZSBpbiB0aGUgZHJhd2VyLlxuICAgICAqXG4gICAgICogUGxhdGZvcm06IEFuZHJvaWRcbiAgICAgKiBQcm92aWRlcjogYWxsXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCBcIkJhY2tncm91bmQgdHJhY2tpbmdcIlxuICAgICAqL1xuICAgIG5vdGlmaWNhdGlvblRpdGxlPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEN1c3RvbSBub3RpZmljYXRpb24gdGV4dCBpbiB0aGUgZHJhd2VyLlxuICAgICAqXG4gICAgICogUGxhdGZvcm06IEFuZHJvaWRcbiAgICAgKiBQcm92aWRlcjogYWxsXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCBcIkVOQUJMRURcIlxuICAgICAqL1xuICAgIG5vdGlmaWNhdGlvblRleHQ/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGFjY2VudCBjb2xvciAoaGV4IHRyaXBsZXQpIHRvIHVzZSBmb3Igbm90aWZpY2F0aW9uLlxuICAgICAqIEVnLiA8Y29kZT4jNENBRjUwPC9jb2RlPi5cbiAgICAgKlxuICAgICAqIFBsYXRmb3JtOiBBbmRyb2lkXG4gICAgICogUHJvdmlkZXI6IGFsbFxuICAgICAqL1xuICAgIG5vdGlmaWNhdGlvbkljb25Db2xvcj86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgZmlsZW5hbWUgb2YgYSBjdXN0b20gbm90aWZpY2F0aW9uIGljb24uXG4gICAgICpcbiAgICAgKiBQbGF0Zm9ybTogQW5kcm9pZFxuICAgICAqIFByb3ZpZGVyOiBhbGxcbiAgICAgKi9cbiAgICBub3RpZmljYXRpb25JY29uTGFyZ2U/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGZpbGVuYW1lIG9mIGEgY3VzdG9tIG5vdGlmaWNhdGlvbiBpY29uLlxuICAgICAqXG4gICAgICogUGxhdGZvcm06IEFuZHJvaWRcbiAgICAgKiBQcm92aWRlcjogYWxsXG4gICAgICovXG4gICAgbm90aWZpY2F0aW9uSWNvblNtYWxsPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEFjdGl2aXR5IHR5cGUuXG4gICAgICogUHJlc3VtYWJseSwgdGhpcyBhZmZlY3RzIGlPUyBHUFMgYWxnb3JpdGhtLlxuICAgICAqXG4gICAgICogUG9zc2libGUgdmFsdWVzOlxuICAgICAqIFwiQXV0b21vdGl2ZU5hdmlnYXRpb25cIiwgXCJPdGhlck5hdmlnYXRpb25cIiwgXCJGaXRuZXNzXCIsIFwiT3RoZXJcIlxuICAgICAqXG4gICAgICogUGxhdGZvcm06IGlPU1xuICAgICAqIFByb3ZpZGVyOiBhbGxcbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IFwiT3RoZXJOYXZpZ2F0aW9uXCJcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2FwcGxlLmNvLzJvSG9mcEh8QXBwbGUgZG9jc31cbiAgICAgKi9cbiAgICBhY3Rpdml0eVR5cGU/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogUGF1c2VzIGxvY2F0aW9uIHVwZGF0ZXMgd2hlbiBhcHAgaXMgcGF1c2VkLlxuICAgICAqXG4gICAgICogUGxhdGZvcm06IGlPU1xuICAgICAqIFByb3ZpZGVyOiBhbGxcbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9hcHBsZS5jby8yQ2JqRVcyfEFwcGxlIGRvY3N9XG4gICAgICovXG4gICAgcGF1c2VMb2NhdGlvblVwZGF0ZXM/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFN3aXRjaCB0byBsZXNzIGFjY3VyYXRlIHNpZ25pZmljYW50IGNoYW5nZXMgYW5kIHJlZ2lvbiBtb25pdG9yeSB3aGVuIGluIGJhY2tncm91bmQuXG4gICAgICpcbiAgICAgKiBQbGF0Zm9ybTogaU9TXG4gICAgICogUHJvdmlkZXI6IGFsbFxuICAgICAqXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBzYXZlQmF0dGVyeU9uQmFja2dyb3VuZD86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2VydmVyIHVybCB3aGVyZSB0byBzZW5kIEhUVFAgUE9TVCB3aXRoIHJlY29yZGVkIGxvY2F0aW9uc1xuICAgICAqXG4gICAgICogUGxhdGZvcm06IGFsbFxuICAgICAqIFByb3ZpZGVyOiBhbGxcbiAgICAgKi9cbiAgICB1cmw/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogU2VydmVyIHVybCB3aGVyZSB0byBzZW5kIGZhaWwgdG8gcG9zdCBsb2NhdGlvbnNcbiAgICAgKlxuICAgICAqIFBsYXRmb3JtOiBhbGxcbiAgICAgKiBQcm92aWRlcjogYWxsXG4gICAgICovXG4gICAgc3luY1VybD86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgaG93IG1hbnkgcHJldmlvdXNseSBmYWlsZWQgbG9jYXRpb25zIHdpbGwgYmUgc2VudCB0byBzZXJ2ZXIgYXQgb25jZS5cbiAgICAgKlxuICAgICAqIFBsYXRmb3JtOiBhbGxcbiAgICAgKiBQcm92aWRlcjogYWxsXG4gICAgICpcbiAgICAgKiBAZGVmYXVsdCAxMDBcbiAgICAgKi9cbiAgICBzeW5jVGhyZXNob2xkPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIEhUVFAgaGVhZGVycyBzZW50IGFsb25nIGluIEhUVFAgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIFBsYXRmb3JtOiBhbGxcbiAgICAgKiBQcm92aWRlcjogYWxsXG4gICAgICovXG4gICAgaHR0cEhlYWRlcnM/OiBhbnk7XG4gICAgLyoqXG4gICAgICogTGltaXQgbWF4aW11bSBudW1iZXIgb2YgbG9jYXRpb25zIHN0b3JlZCBpbnRvIGRiLlxuICAgICAqXG4gICAgICogUGxhdGZvcm06IGFsbFxuICAgICAqIFByb3ZpZGVyOiBhbGxcbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IDEwMDAwXG4gICAgICovXG4gICAgbWF4TG9jYXRpb25zPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEN1c3RvbWl6YXRpb24gcG9zdCB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIFBsYXRmb3JtOiBhbGxcbiAgICAgKiBQcm92aWRlcjogYWxsXG4gICAgICovXG4gICAgcG9zdFRlbXBsYXRlPzogYW55O1xufVxuLyoqXG4gKiBTZXQgbG9jYXRpb24gc2VydmljZSBwcm92aWRlciBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXVyb244NS9jb3Jkb3ZhLXBsdWdpbi1iYWNrZ3JvdW5kLWdlb2xvY2F0aW9uL3dpa2kvQW5kcm9pZC1wcm92aWRlcnNcbiAqXG4gKiBQb3NzaWJsZSB2YWx1ZXM6XG4gKiAgQU5EUk9JRF9ESVNUQU5DRV9GSUxURVJfUFJPVklERVI6IDAsXG4gKiAgQU5EUk9JRF9BQ1RJVklUWV9QUk9WSURFUjogMVxuICpcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWNsYXJlIGVudW0gQmFja2dyb3VuZEdlb2xvY2F0aW9uUHJvdmlkZXIge1xuICAgIEFORFJPSURfRElTVEFOQ0VfRklMVEVSX1BST1ZJREVSID0gMCxcbiAgICBBTkRST0lEX0FDVElWSVRZX1BST1ZJREVSID0gMVxufVxuLyoqXG4gKiBEZXNpcmVkIGFjY3VyYWN5IGluIG1ldGVycy4gUG9zc2libGUgdmFsdWVzIFswLCAxMCwgMTAwLCAxMDAwXS5cbiAqIFRoZSBsb3dlciB0aGUgbnVtYmVyLCB0aGUgbW9yZSBwb3dlciBkZXZvdGVkIHRvIEdlb0xvY2F0aW9uIHJlc3VsdGluZyBpbiBoaWdoZXIgYWNjdXJhY3kgcmVhZGluZ3MuXG4gKiAxMDAwIHJlc3VsdHMgaW4gbG93ZXN0IHBvd2VyIGRyYWluIGFuZCBsZWFzdCBhY2N1cmF0ZSByZWFkaW5ncy5cbiAqXG4gKiBQb3NzaWJsZSB2YWx1ZXM6XG4gKiAgSElHSDogMFxuICogIE1FRElVTTogMTBcbiAqICBMT1c6IDEwMFxuICogIFBBU1NJVkU6IDEwMDBcbiAqXG4gKiBlbnVtIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBkZWNsYXJlIGVudW0gQmFja2dyb3VuZEdlb2xvY2F0aW9uQWNjdXJhY3kge1xuICAgIEhJR0ggPSAwLFxuICAgIE1FRElVTSA9IDEwLFxuICAgIExPVyA9IDEwMCxcbiAgICBQQVNTSVZFID0gMTAwMFxufVxuLyoqXG4gKiBVc2VkIGluIHRoZSBzd2l0Y2hNb2RlIGZ1bmN0aW9uXG4gKlxuICogUG9zc2libGUgdmFsdWVzOlxuICogIEJBQ0tHUk9VTkQ6IDBcbiAqICBGT1JFR1JPVU5EOiAxXG4gKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuZXhwb3J0IGRlY2xhcmUgZW51bSBCYWNrZ3JvdW5kR2VvbG9jYXRpb25Nb2RlIHtcbiAgICBCQUNLR1JPVU5EID0gMCxcbiAgICBGT1JFR1JPVU5EID0gMVxufVxuZXhwb3J0IGRlY2xhcmUgZW51bSBCYWNrZ3JvdW5kR2VvbG9jYXRpb25JT1NBY3Rpdml0eSB7XG4gICAgQXV0b21vdGl2ZU5hdmlnYXRpb24gPSBcIkF1dG9tb3RpdmVOYXZpZ2F0aW9uXCIsXG4gICAgT3RoZXJOYXZpZ2F0aW9uID0gXCJPdGhlck5hdmlnYXRpb25cIixcbiAgICBGaXRuZXNzID0gXCJGaXRuZXNzXCIsXG4gICAgT3RoZXIgPSBcIk90aGVyXCJcbn1cbi8qKlxuICogQG5hbWUgQmFja2dyb3VuZCBHZW9sb2NhdGlvblxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIHBsdWdpbiBwcm92aWRlcyBmb3JlZ3JvdW5kIGFuZCBiYWNrZ3JvdW5kIGdlb2xvY2F0aW9uIHdpdGggYmF0dGVyeS1zYXZpbmcgXCJjaXJjdWxhciByZWdpb24gbW9uaXRvcmluZ1wiIGFuZCBcInN0b3AgZGV0ZWN0aW9uXCIuIEZvclxuICogbW9yZSBkZXRhaWwsIHBsZWFzZSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hdXJvbjg1L2NvcmRvdmEtcGx1Z2luLWJhY2tncm91bmQtZ2VvbG9jYXRpb25cbiAqIEB1c2FnZVxuICpcbiAqIEJhY2tncm91bmRHZW9sb2NhdGlvbiBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gYXBwLnRzIGFuZCBvciBiZWZvcmUgR2VvbG9jYXRpb24uIE90aGVyd2lzZSB0aGUgcGxhdGZvcm0gd2lsbCBub3QgYXNrIHlvdSBmb3IgYmFja2dyb3VuZCB0cmFja2luZyBwZXJtaXNzaW9uLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IEJhY2tncm91bmRHZW9sb2NhdGlvbiwgQmFja2dyb3VuZEdlb2xvY2F0aW9uQ29uZmlnLCBCYWNrZ3JvdW5kR2VvbG9jYXRpb25FdmVudHMsIEJhY2tncm91bmRHZW9sb2NhdGlvblJlc3BvbnNlIH0gZnJvbSAnQGF3ZXNvbWUtY29yZG92YS1wbHVnaW5zL2JhY2tncm91bmQtZ2VvbG9jYXRpb24vbmd4JztcbiAqXG4gKiBjb25zdHJ1Y3Rvcihwcml2YXRlIGJhY2tncm91bmRHZW9sb2NhdGlvbjogQmFja2dyb3VuZEdlb2xvY2F0aW9uKSB7IH1cbiAqXG4gKiAuLi5cbiAqXG4gKiBjb25zdCBjb25maWc6IEJhY2tncm91bmRHZW9sb2NhdGlvbkNvbmZpZyA9IHtcbiAqICAgICAgICAgICAgIGRlc2lyZWRBY2N1cmFjeTogMTAsXG4gKiAgICAgICAgICAgICBzdGF0aW9uYXJ5UmFkaXVzOiAyMCxcbiAqICAgICAgICAgICAgIGRpc3RhbmNlRmlsdGVyOiAzMCxcbiAqICAgICAgICAgICAgIGRlYnVnOiB0cnVlLCAvLyAgZW5hYmxlIHRoaXMgaGVhciBzb3VuZHMgZm9yIGJhY2tncm91bmQtZ2VvbG9jYXRpb24gbGlmZS1jeWNsZS5cbiAqICAgICAgICAgICAgIHN0b3BPblRlcm1pbmF0ZTogZmFsc2UsIC8vIGVuYWJsZSB0aGlzIHRvIGNsZWFyIGJhY2tncm91bmQgbG9jYXRpb24gc2V0dGluZ3Mgd2hlbiB0aGUgYXBwIHRlcm1pbmF0ZXNcbiAqICAgICB9O1xuICpcbiAqIHRoaXMuYmFja2dyb3VuZEdlb2xvY2F0aW9uLmNvbmZpZ3VyZShjb25maWcpXG4gKiAgIC50aGVuKCgpID0+IHtcbiAqXG4gKiAgICAgdGhpcy5iYWNrZ3JvdW5kR2VvbG9jYXRpb24ub24oQmFja2dyb3VuZEdlb2xvY2F0aW9uRXZlbnRzLmxvY2F0aW9uKS5zdWJzY3JpYmUoKGxvY2F0aW9uOiBCYWNrZ3JvdW5kR2VvbG9jYXRpb25SZXNwb25zZSkgPT4ge1xuICogICAgICAgY29uc29sZS5sb2cobG9jYXRpb24pO1xuICpcbiAqICAgICAgIC8vIElNUE9SVEFOVDogIFlvdSBtdXN0IGV4ZWN1dGUgdGhlIGZpbmlzaCBtZXRob2QgaGVyZSB0byBpbmZvcm0gdGhlIG5hdGl2ZSBwbHVnaW4gdGhhdCB5b3UncmUgZmluaXNoZWQsXG4gKiAgICAgICAvLyBhbmQgdGhlIGJhY2tncm91bmQtdGFzayBtYXkgYmUgY29tcGxldGVkLiAgWW91IG11c3QgZG8gdGhpcyByZWdhcmRsZXNzIGlmIHlvdXIgb3BlcmF0aW9ucyBhcmUgc3VjY2Vzc2Z1bCBvciBub3QuXG4gKiAgICAgICAvLyBJRiBZT1UgRE9OJ1QsIGlvcyB3aWxsIENSQVNIIFlPVVIgQVBQIGZvciBzcGVuZGluZyB0b28gbXVjaCB0aW1lIGluIHRoZSBiYWNrZ3JvdW5kLlxuICogICAgICAgdGhpcy5iYWNrZ3JvdW5kR2VvbG9jYXRpb24uZmluaXNoKCk7IC8vIEZPUiBJT1MgT05MWVxuICogICAgIH0pO1xuICpcbiAqICAgfSk7XG4gKlxuICogLy8gc3RhcnQgcmVjb3JkaW5nIGxvY2F0aW9uXG4gKiB0aGlzLmJhY2tncm91bmRHZW9sb2NhdGlvbi5zdGFydCgpO1xuICpcbiAqIC8vIElmIHlvdSB3aXNoIHRvIHR1cm4gT0ZGIGJhY2tncm91bmQtdHJhY2tpbmcsIGNhbGwgdGhlICNzdG9wIG1ldGhvZC5cbiAqIHRoaXMuYmFja2dyb3VuZEdlb2xvY2F0aW9uLnN0b3AoKTtcbiAqXG4gKiBgYGBcbiAqIEBpbnRlcmZhY2VzXG4gKiBCYWNrZ3JvdW5kR2VvbG9jYXRpb25SZXNwb25zZVxuICogQmFja2dyb3VuZEdlb2xvY2F0aW9uQ29uZmlnXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEJhY2tncm91bmRHZW9sb2NhdGlvbiBleHRlbmRzIEF3ZXNvbWVDb3Jkb3ZhTmF0aXZlUGx1Z2luIHtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmUgdGhlIHBsdWdpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtCYWNrZ3JvdW5kR2VvbG9jYXRpb25Db25maWd9IG9wdGlvbnMgQW4gb2JqZWN0IG9mIHR5cGUgQ29uZmlnXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBjb25maWd1cmUob3B0aW9uczogQmFja2dyb3VuZEdlb2xvY2F0aW9uQ29uZmlnKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIFR1cm4gT04gdGhlIGJhY2tncm91bmQtZ2VvbG9jYXRpb24gc3lzdGVtLlxuICAgICAqIFRoZSB1c2VyIHdpbGwgYmUgdHJhY2tlZCB3aGVuZXZlciB0aGV5IHN1c3BlbmQgdGhlIGFwcC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgc3RhcnQoKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIFR1cm4gT0ZGIGJhY2tncm91bmQtdHJhY2tpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgc3RvcCgpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogSW5mb3JtIHRoZSBuYXRpdmUgcGx1Z2luIHRoYXQgeW91J3JlIGZpbmlzaGVkLCB0aGUgYmFja2dyb3VuZC10YXNrIG1heSBiZSBjb21wbGV0ZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgZmluaXNoKCk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBGb3JjZSB0aGUgcGx1Z2luIHRvIGVudGVyIFwibW92aW5nXCIgb3IgXCJzdGF0aW9uYXJ5XCIgc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpc01vdmluZyB7Ym9vbGVhbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIGNoYW5nZVBhY2UoaXNNb3Zpbmc6IGJvb2xlYW4pOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogU2V0dXAgY29uZmlndXJhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMge0JhY2tncm91bmRHZW9sb2NhdGlvbkNvbmZpZ31cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHNldENvbmZpZyhvcHRpb25zOiBCYWNrZ3JvdW5kR2VvbG9jYXRpb25Db25maWcpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJyZW50IHN0YXRpb25hcnlMb2NhdGlvbiBpZiBhdmFpbGFibGUuIG51bGwgaWYgbm90XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMb2NhdGlvbj59XG4gICAgICovXG4gICAgZ2V0U3RhdGlvbmFyeUxvY2F0aW9uKCk6IFByb21pc2U8QmFja2dyb3VuZEdlb2xvY2F0aW9uUmVzcG9uc2U+O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIHN0YXRpb25hcnktcmVnaW9uIGxpc3RlbmVyLiBXaGVuZXZlciB0aGUgZGV2aWNlcyBlbnRlcnMgXCJzdGF0aW9uYXJ5LW1vZGVcIixcbiAgICAgKiB5b3VyICNzdWNjZXNzIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgd2l0aCAjbG9jYXRpb24gcGFyYW0gY29udGFpbmluZyAjcmFkaXVzIG9mIHJlZ2lvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBvblN0YXRpb25hcnkoKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGxvY2F0aW9uIGlzIGVuYWJsZWQgb24gdGhlIGRldmljZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyPn0gUmV0dXJucyBhIHByb21pc2Ugd2l0aCBpbnQgYXJndW1lbnQgdGhhdCB0YWtlcyB2YWx1ZXMgMCwgMSAodHJ1ZSkuXG4gICAgICovXG4gICAgaXNMb2NhdGlvbkVuYWJsZWQoKTogUHJvbWlzZTxudW1iZXI+O1xuICAgIC8qKlxuICAgICAqIERpc3BsYXkgYXBwIHNldHRpbmdzIHRvIGNoYW5nZSBwZXJtaXNzaW9uc1xuICAgICAqL1xuICAgIHNob3dBcHBTZXR0aW5ncygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIERpc3BsYXkgZGV2aWNlIGxvY2F0aW9uIHNldHRpbmdzXG4gICAgICovXG4gICAgc2hvd0xvY2F0aW9uU2V0dGluZ3MoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgY2FuIGJlIHVzZWQgdG8gZGV0ZWN0IHVzZXIgY2hhbmdlcyBpbiBsb2NhdGlvbiBzZXJ2aWNlcyBzZXR0aW5ncy5cbiAgICAgKiBJZiB1c2VyIGVuYWJsZSBvciBkaXNhYmxlIGxvY2F0aW9uIHNlcnZpY2VzIHRoZW4gc3VjY2VzcyBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkLlxuICAgICAqIEluIGNhc2Ugb3IgIChTZXR0aW5nTm90Rm91bmRFeGNlcHRpb24pIGZhaWwgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlPG51bWJlcj59XG4gICAgICovXG4gICAgd2F0Y2hMb2NhdGlvbk1vZGUoKTogT2JzZXJ2YWJsZTxudW1iZXI+O1xuICAgIC8qKlxuICAgICAqIFN0b3Agd2F0Y2hpbmcgZm9yIGxvY2F0aW9uIG1vZGUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgc3RvcFdhdGNoaW5nTG9jYXRpb25Nb2RlKCk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBNZXRob2Qgd2lsbCByZXR1cm4gYWxsIHN0b3JlZCBsb2NhdGlvbnMuXG4gICAgICogTG9jYXRpb25zIGFyZSBzdG9yZWQgd2hlbjpcbiAgICAgKiAgLSBjb25maWcuc3RvcE9uVGVybWluYXRlIGlzIGZhbHNlIGFuZCBtYWluIGFjdGl2aXR5IHdhcyBraWxsZWRcbiAgICAgKiAgICBieSB0aGUgc3lzdGVtXG4gICAgICogIG9yXG4gICAgICogIC0gb3B0aW9uLmRlYnVnIGlzIHRydWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgZ2V0TG9jYXRpb25zKCk6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBNZXRob2Qgd2lsbCByZXR1cm4gbG9jYXRpb25zLCB3aGljaCBoYXMgbm90IGJlZW4geWV0IHBvc3RlZCB0byBzZXJ2ZXIuIE5PVEU6IExvY2F0aW9ucyBkb2VzIGNvbnRhaW4gbG9jYXRpb25JZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgZ2V0VmFsaWRMb2NhdGlvbnMoKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIERlbGV0ZSBzdG9yZWQgbG9jYXRpb24gYnkgZ2l2ZW4gbG9jYXRpb25JZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhdGlvbklkIHtudW1iZXJ9XG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBkZWxldGVMb2NhdGlvbihsb2NhdGlvbklkOiBudW1iZXIpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFsbCBzdG9yZWQgbG9jYXRpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBkZWxldGVBbGxMb2NhdGlvbnMoKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIE5vcm1hbGx5IHBsdWdpbiB3aWxsIGhhbmRsZSBzd2l0Y2hpbmcgYmV0d2VlbiBCQUNLR1JPVU5EIGFuZCBGT1JFR1JPVU5EIG1vZGUgaXRzZWxmLlxuICAgICAqIENhbGxpbmcgc3dpdGNoTW9kZSB5b3UgY2FuIG92ZXJyaWRlIHBsdWdpbiBiZWhhdmlvciBhbmQgZm9yY2UgcGx1Z2luIHRvIHN3aXRjaCBpbnRvIG90aGVyIG1vZGUuXG4gICAgICpcbiAgICAgKiBJbiBGT1JFR1JPVU5EIG1vZGUgcGx1Z2luIHVzZXMgaU9TIGxvY2FsIG1hbmFnZXIgdG8gcmVjZWl2ZSBsb2NhdGlvbnMgYW5kIGJlaGF2aW9yIGlzIGFmZmVjdGVkIGJ5IG9wdGlvbi5kZXNpcmVkQWNjdXJhY3kgYW5kIG9wdGlvbi5kaXN0YW5jZUZpbHRlci5cbiAgICAgKiBJbiBCQUNLR1JPVU5EIG1vZGUgcGx1Z2luIHVzZXMgc2lnbmlmaWNhbnQgY2hhbmdlcyBhbmQgcmVnaW9uIG1vbml0b3JpbmcgdG8gcmVjZWl2ZSBsb2NhdGlvbnMgYW5kIHVzZXMgb3B0aW9uLnN0YXRpb25hcnlSYWRpdXMgb25seS5cbiAgICAgKlxuICAgICAqIEJhY2tncm91bmRHZW9sb2NhdGlvbi5Nb2RlLkZPUkVHUk9VTkRcbiAgICAgKiBCYWNrZ3JvdW5kR2VvbG9jYXRpb24uTW9kZS5CQUNLR1JPVU5EXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9kZUlkIHtudW1iZXJ9XG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBzd2l0Y2hNb2RlKG1vZGVJZDogbnVtYmVyKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhbGwgbG9nZ2VkIGV2ZW50cy4gVXNlZnVsIGZvciBwbHVnaW4gZGVidWdnaW5nLiBQYXJhbWV0ZXIgbGltaXQgbGltaXRzIG51bWJlciBvZiByZXR1cm5lZCBlbnRyaWVzLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWF1cm9uODUvY29yZG92YS1wbHVnaW4tYmFja2dyb3VuZC1nZW9sb2NhdGlvbi90cmVlL3YyLjIuMSNkZWJ1Z2dpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICogQHBhcmFtIGZyb21JZFxuICAgICAqIEBwYXJhbSBtaW5MZXZlbFxuICAgICAqIEBwYXJhbSBsaW1pdCB7bnVtYmVyfSBMaW1pdHMgdGhlIG51bWJlciBvZiBlbnRyaWVzXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBnZXRMb2dFbnRyaWVzKGxpbWl0OiBudW1iZXIsIGZyb21JZDogbnVtYmVyLCBtaW5MZXZlbDogQmFja2dyb3VuZEdlb2xvY2F0aW9uTG9nTGV2ZWwpOiBQcm9taXNlPEJhY2tncm91bmRHZW9sb2NhdGlvbkxvZ0VudHJ5W10+O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhbGwgbG9nZ2VkIGV2ZW50cy4gVXNlZnVsIGZvciBwbHVnaW4gZGVidWdnaW5nLiBQYXJhbWV0ZXIgbGltaXQgbGltaXRzIG51bWJlciBvZiByZXR1cm5lZCBlbnRyaWVzLlxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWF1cm9uODUvY29yZG92YS1wbHVnaW4tYmFja2dyb3VuZC1nZW9sb2NhdGlvbi90cmVlL3YyLjIuMSNkZWJ1Z2dpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAgICAgKi9cbiAgICBnZXRDb25maWcoKTogUHJvbWlzZTxhbnk+O1xuICAgIC8qKlxuICAgICAqIE9uZSB0aW1lIGxvY2F0aW9uIGNoZWNrIHRvIGdldCBjdXJyZW50IGxvY2F0aW9uIG9mIHRoZSBkZXZpY2UuXG4gICAgICoge3RpbWVvdXQ6IE1heGltdW0gdGltZSBpbiBtaWxsaXNlY29uZHMgZGV2aWNlIHdpbGwgd2FpdCBmb3IgbG9jYXRpb24sXG4gICAgICogbWF4aW11bUFnZTogTWF4aW11bSBhZ2UgaW4gbWlsbGlzZWNvbmRzIG9mIGEgcG9zc2libGUgY2FjaGVkIGxvY2F0aW9uIHRoYXQgaXMgYWNjZXB0YWJsZSB0byByZXR1cm47XG4gICAgICogZW5hYmxlSGlnaEFjY3VyYWN5OiBpZiB0cnVlIGFuZCBpZiB0aGUgZGV2aWNlIGlzIGFibGUgdG8gcHJvdmlkZSBhIG1vcmUgYWNjdXJhdGUgcG9zaXRpb24sIGl0IHdpbGwgZG8gc299XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0JhY2tncm91bmRHZW9sb2NhdGlvbkN1cnJlbnRQb3NpdGlvbkNvbmZpZ30gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gICAgICovXG4gICAgZ2V0Q3VycmVudExvY2F0aW9uKG9wdGlvbnM/OiBCYWNrZ3JvdW5kR2VvbG9jYXRpb25DdXJyZW50UG9zaXRpb25Db25maWcpOiBQcm9taXNlPEJhY2tncm91bmRHZW9sb2NhdGlvblJlc3BvbnNlPjtcbiAgICAvKipcbiAgICAgKiBDaGVjayBzdGF0dXMgb2YgdGhlIHNlcnZpY2VcbiAgICAgKi9cbiAgICBjaGVja1N0YXR1cygpOiBQcm9taXNlPFNlcnZpY2VTdGF0dXM+O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IGJhY2tncm91bmQgdGFzayAoaU9TIG9ubHkpXG4gICAgICpcbiAgICAgKiBUbyBwZXJmb3JtIGFueSBsb25nIHJ1bm5pbmcgb3BlcmF0aW9uIG9uIGlPU1xuICAgICAqIHlvdSBuZWVkIHRvIGNyZWF0ZSBiYWNrZ3JvdW5kIHRhc2tcbiAgICAgKiBJTVBPUlRBTlQ6IHRhc2sgaGFzIHRvIGJlIGVuZGVkIGJ5IGVuZFRhc2tcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcj59IHRhc2tLZXlcbiAgICAgKi9cbiAgICBzdGFydFRhc2soKTogUHJvbWlzZTxudW1iZXI+O1xuICAgIC8qKlxuICAgICAqICBFbmQgYmFja2dyb3VuZCB0YXNrIGluZGVudGlmaWVkIGJ5IHRhc2tLZXkgKGlPUyBvbmx5KVxuICAgICAqXG4gICAgICogQHBhcmFtIHRhc2tLZXlcbiAgICAgKi9cbiAgICBlbmRUYXNrKHRhc2tLZXk6IG51bWJlcik6IFByb21pc2U8YW55PjtcbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWwgdGFzayB0aGF0IGdldHMgZXhlY3V0ZWQgd2hlbiB0aGUgYXBwIGlzIHRlcm1pbmF0ZWQsIGJ1dFxuICAgICAqIHRoZSBwbHVnaW4gd2FzIGNvbmZpZ3VyZWQgdG8gY29udGludWUgcnVubmluZyBpbiB0aGUgYmFja2dyb3VuZFxuICAgICAqIChvcHRpb24gPGNvZGU+c3RvcE9uVGVybWluYXRlOiBmYWxzZTwvY29kZT4pLlxuICAgICAqXG4gICAgICogSW4gdGhpcyBzY2VuYXJpbyB0aGUgQWN0aXZpdHkgd2FzIGtpbGxlZCBieSB0aGUgc3lzdGVtIGFuZCBhbGwgcmVnaXN0ZXJlZFxuICAgICAqIGV2ZW50IGxpc3RlbmVycyB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQgdW50aWwgdGhlIGFwcCBpcyByZWxhdW5jaGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgQmFja2dyb3VuZEdlb2xvY2F0aW9uLmhlYWRsZXNzVGFzayhmdW5jdGlvbihldmVudCkge1xuICAgICAqXG4gICAgICogICAgICBpZiAoZXZlbnQubmFtZSA9PT0gJ2xvY2F0aW9uJyB8fCBldmVudC5uYW1lID09PSAnc3RhdGlvbmFyeScpIHtcbiAgICAgKiAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICogICAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCAnaHR0cDovLzE5Mi4xNjguODEuMTQ6MzAwMC9oZWFkbGVzcycpO1xuICAgICAqICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAqICAgICAgICAgIHhoci5zZW5kKEpTT04uc3RyaW5naWZ5KGV2ZW50LnBhcmFtcykpO1xuICAgICAqICAgICAgfVxuICAgICAqXG4gICAgICogICAgICByZXR1cm4gJ1Byb2Nlc3NpbmcgZXZlbnQ6ICcgKyBldmVudC5uYW1lOyAvLyB3aWxsIGJlIGxvZ2dlZFxuICAgICAqICB9KTtcbiAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAqL1xuICAgIGhlYWRsZXNzVGFzayhmdW5jOiBhbnkpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogRm9yY2Ugc3luYyBvZiBwZW5kaW5nIGxvY2F0aW9ucy5cbiAgICAgKiBPcHRpb24gPGNvZGU+c3luY1RocmVzaG9sZDwvY29kZT4gd2lsbCBiZSBpZ25vcmVkIGFuZCBhbGwgcGVuZGluZyBsb2NhdGlvbnMgd2lsbCBiZSBpbW1lZGlhdGVseSBwb3N0ZWQgdG8gPGNvZGU+c3luY1VybDwvY29kZT4gaW4gc2luZ2xlIGJhdGNoLlxuICAgICAqXG4gICAgICogUGxhdGZvcm06IEFuZHJvaWQsIGlPU1xuICAgICAqL1xuICAgIGZvcmNlU3luYygpOiBQcm9taXNlPGFueT47XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXIuXG4gICAgICpcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggXCI8Y29kZT4yODUgVXBkYXRlcyBOb3QgUmVxdWlyZWQ8L2NvZGU+XCIgdG8gcG9zdC9zeW5jIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tGblxuICAgICAqL1xuICAgIG9uKGV2ZW50OiBCYWNrZ3JvdW5kR2VvbG9jYXRpb25FdmVudHMpOiBPYnNlcnZhYmxlPEJhY2tncm91bmRHZW9sb2NhdGlvblJlc3BvbnNlPjtcbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIGFsbCBldmVudCBsaXN0ZW5lcnMgZm9yIGdpdmVuIGV2ZW50LlxuICAgICAqXG4gICAgICogSWYgcGFyYW1ldGVyIDxjb2RlPmV2ZW50PC9jb2RlPiBpcyBub3QgcHJvdmlkZWQgdGhlbiBhbGwgZXZlbnQgbGlzdGVuZXJzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqL1xuICAgIHJlbW92ZUFsbExpc3RlbmVycyhldmVudD86IEJhY2tncm91bmRHZW9sb2NhdGlvbkV2ZW50cyk6IFByb21pc2U8YW55Pjtcbn1cbiJdfQ==